import { Injectable, defineInjectable } from '@angular/core';
import { Observable } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
//import { environment } from '../environments/environment';
const Web3 = require('web3');
let ansible = require('ansiblejs');
let ansibleRelayAbi = require('../ansible_relay.abi');
class SignedState {
}
class AnsibleEvent {
}
class AnsibleService {
    constructor() {
        this.ansibleRelayAddress = "0x0";
        this.relayID = 0;
        this.FULL_RANGE = { fromBlock: 0, toBlock: 'latest' };
        this.checkAndInstantiateWeb3 = () => {
            // Checking if Web3 has been injected by the browser (Mist/MetaMask)
            if (typeof window.web3 !== 'undefined') {
                console.warn('Using web3 detected from external source. If you find that your accounts don\'t appear or you have 0 MetaCoin, ensure you\'ve configured that source properly. If using MetaMask, see the following link. Feel free to delete this warning. :) http://truffleframework.com/tutorials/truffle-and-metamask');
                // Use Mist/MetaMask's provider
                this.web3 = new Web3(window.web3.currentProvider);
            }
            else {
                this.web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
                /*console.warn(
                            'No web3 detected. Falling back to ${environment.HttpProvider}. You should remove this fallback when you deploy live, as it\'s inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask'
                          );
                          // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)
                          this.web3 = new Web3(
                            new Web3.providers.HttpProvider(environment.HttpProvider)
                         );*/
            }
        };
        this.checkAndInstantiateWeb3();
        this.ansibleRelay = this.web3.eth.contract(ansibleRelayAbi).at(this.ansibleRelayAddress);
        this.getAccounts().subscribe(accs => {
            this.accounts = accs;
            this.account = this.accounts[0];
        }, err => alert(err));
    }
    /**
     * @param {?} speaker
     * @param {?} data
     * @return {?}
     */
    signInitialAnsible(speaker, data) {
        let /** @type {?} */ state = this.createInitialState(speaker, data);
        return this.sign(state);
    }
    /**
     * @param {?} speaker
     * @param {?} data
     * @return {?}
     */
    createInitialState(speaker, data) {
        let /** @type {?} */ state = [];
        state = ansible.appendUint16(state, this.relayID);
        state = ansible.appendAddress(state, speaker);
        state.concat(data);
        return state;
    }
    /**
     * @param {?} ansibleID
     * @param {?} data
     * @return {?}
     */
    createAnsibleState(ansibleID, data) {
        let /** @type {?} */ state = [];
        state = ansible.appendUint16(state, this.relayID);
        state = ansible.appendUint64(state, ansibleID);
        state.concat(data);
        return state;
    }
    /**
     * @param {?} ansibleID
     * @param {?} data
     * @return {?}
     */
    signAnsibleState(ansibleID, data) {
        let /** @type {?} */ state = this.createAnsibleState(ansibleID, data);
        return this.sign(state);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    sign(data) {
        return Observable.create(observer => {
            this.web3.eth.sign(this.account, data, function (error, sig) {
                if (!error) {
                    let /** @type {?} */ signedState = new SignedState();
                    // sig is the returned signature. Separate out the signature components:
                    signedState.data = sig.substr(2, sig.length);
                    signedState.rs = ['0x' + signedState.data.substr(0, 64)];
                    signedState.ss = ['0x' + signedState.data.substr(64, 64)];
                    signedState.vs = [parseInt(signedState.data.substr(128, 2), 16)];
                    observer.next(signedState);
                }
                else {
                    observer.error(error);
                }
            });
        });
    }
    /**
     * @return {?}
     */
    getAccounts() {
        return Observable.create(observer => {
            this.web3.eth.getAccounts((err, accs) => {
                if (err != null) {
                    observer.error('There was an error fetching your accounts.');
                }
                if (accs.length === 0) {
                    observer.error('Couldn\'t get any accounts! Make sure your Ethereum client is configured correctly.');
                }
                observer.next(accs);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @return {?}
     */
    get(ansibleID) {
        return Observable.create(observer => {
            this.ansibleRelay.getAnsible.call(ansibleID, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} speaker
     * @param {?} state
     * @param {?} deposit
     * @return {?}
     */
    open(speaker, state, deposit) {
        return Observable.create(observer => {
            this.ansibleRelay.openAnsible.call(speaker, state.data, state.vs, state.rs, state.ss, { value: deposit }, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @param {?} state
     * @param {?} deposit
     * @return {?}
     */
    join(ansibleID, state, deposit) {
        return Observable.create(observer => {
            this.ansibleRelay.joinAnsible.call(ansibleID, state.data, state.vs, state.rs, state.ss, { value: deposit }, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @param {?} one
     * @param {?} two
     * @return {?}
     */
    challenge(ansibleID, one, two) {
        return Observable.create(observer => {
            this.ansibleRelay.challenge.call(ansibleID, one.data, one.vs, one.rs, one.ss, two.data, two.vs, two.rs, two.ss, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @param {?} one
     * @return {?}
     */
    challengeState(ansibleID, one) {
        return Observable.create(observer => {
            this.ansibleRelay.challengeState.call(ansibleID, one.data, one.vs, one.rs, one.ss, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @param {?} enforceExpiry
     * @param {?} state
     * @return {?}
     */
    checkpoint(ansibleID, enforceExpiry, state) {
        return Observable.create(observer => {
            this.ansibleRelay.checkpoint.call(ansibleID, enforceExpiry, state.data, state.vs, state.rs, state.ss, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @return {?}
     */
    claimExpiry(ansibleID) {
        return Observable.create(observer => {
            this.ansibleRelay.claimExpiry.call(ansibleID, function (err, result) {
                if (err != null) {
                    observer.error(err);
                    return;
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} ansibleID
     * @param {?} state
     * @return {?}
     */
    close(ansibleID, state) {
        return Observable.create(observer => {
            this.ansibleRelay.closeAnsible.call(ansibleID, state.data, state.rs, state.vs, state.ss, function (err, result) {
                if (err != null) {
                    observer.error(err);
                }
                observer.next(result);
                observer.complete();
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerEvents(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return this.getEvents(indices);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleEvents(id) {
        let /** @type {?} */ indices = { id: id };
        return this.getEvents(indices);
    }
    /**
     * @param {?} indices
     * @return {?}
     */
    getEvents(indices) {
        let /** @type {?} */ count = 0;
        let /** @type {?} */ max = 6;
        let /** @type {?} */ events = [];
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleOpened(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
            this.ansibleRelay.events.AnsibleJoined(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
            this.ansibleRelay.events.AnsibleClosed(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
            this.ansibleRelay.events.AnsibleExpired(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
            this.ansibleRelay.events.AnsibleCheckpoint(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
            this.ansibleRelay.events.AnsibleChallenged(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    events.concat(data.json());
                    count++;
                    if (count == max) {
                        observer.next(events);
                        observer.complete();
                    }
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerOpens(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleOpened(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerCloses(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClosed(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerChallenges(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleChallenged(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerClaims(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClaimed(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerJoins(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleJoined(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    getSpeakerCheckpoints(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleCheckpoint(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleOpens(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleOpened(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleCloses(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClosed(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleChallenges(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleChallenged(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleClaims(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClaimed(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleJoins(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleJoined(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAnsibleCheckpoints(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleCheckpoints(indices, this.FULL_RANGE).get((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerOpens(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleOpened(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerCloses(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClosed(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerChallenges(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleChallenged(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerClaims(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClaimed(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerJoins(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleJoined(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerCheckpoints(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleCheckpoint(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    watchAnsibleCloses(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClosed(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    watchAnsibleChallenges(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleChallenged(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchAnsibleClaims(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleClaimed(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    watchAnsibleJoins(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleJoined(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    watchAnsibleCheckpoints(id) {
        let /** @type {?} */ indices = { id: id };
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleCheckpoint(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
    /**
     * @param {?} speaker
     * @return {?}
     */
    watchSpeakerEvents(speaker) {
        let /** @type {?} */ indices = { speaker: speaker };
        return this.watchEvents(indices);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    watchAnsibleEvents(id) {
        let /** @type {?} */ indices = { id: id };
        return this.watchEvents(indices);
    }
    /**
     * @param {?} indices
     * @return {?}
     */
    watchEvents(indices) {
        return Observable.create(observer => {
            this.ansibleRelay.events.AnsibleOpened(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
            this.ansibleRelay.events.AnsibleJoined(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
            this.ansibleRelay.events.AnsibleClosed(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
            this.ansibleRelay.events.AnsibleExpired(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
            this.ansibleRelay.events.AnsibleCheckpoint(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
            this.ansibleRelay.events.AnsibleChallenged(indices).watch((error, data) => {
                if (error) {
                    observer.error(error);
                }
                else {
                    observer.next(data.json());
                }
            });
        });
    }
}
AnsibleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
AnsibleService.ctorParameters = () => [];
/** @nocollapse */ AnsibleService.ngInjectableDef = defineInjectable({ factory: function AnsibleService_Factory() { return new AnsibleService(); }, token: AnsibleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Public API Surface of ansible
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { SignedState, AnsibleEvent, AnsibleService };
//# sourceMappingURL=ng-angular.js.map
